# SANAD TRADER v3.1 — IMPLEMENTATION PLAN

**Branch:** `v3.1-ticket-4`
**Started:** 2026-02-22
**Last Updated:** 2026-02-22

## What v3.1 Is About

v3.1 replaces the slow subprocess-based pipeline (v3.0: `signal_router.py → subprocess sanad_pipeline.py`) with:
- **Hot Path:** Direct function calls (fast_decision_engine) — <3s decisions
- **Cold Path:** Async analysis queue — LLM analysis runs in background after execution
- **SQLite truth:** Single DB for positions, decisions, async tasks, learning stats
- **Learning loop:** Automated Thompson/UCB1 updates from realized outcomes

---

## TICKET STATUS

### ✅ Ticket 1: SQLite State Store (`state_store.py`)
**Commit:** `1e9f9bc`
- `init_db()` — creates all tables (decisions, positions, async_tasks, bandit_strategy_stats, source_ucb_stats)
- `get_connection()` — 250ms fast-fail with `DBBusyError`
- `try_open_position_atomic()` — atomic decision + position + task in one transaction
- `insert_decision()` — public API for SKIP/BLOCK logging
- `update_position_close()` — close with PnL + sets `learning_status='PENDING'`
- WAL journal mode, idempotent via PRIMARY KEY / UNIQUE constraints

### ✅ Ticket 2: Canonical ID Generation (`ids.py`)
**Commit:** `1e9f9bc`
- `make_signal_id()` — SHA-256 from stable content (no enrichment metrics like rugcheck_score/volume_24h)
- `make_decision_id()` — SHA-256(signal_id + policy_version)
- `make_position_id()` — SHA-256(decision_id + ordinal)
- Safe timestamp parsing with fallback buckets
- 10-min time bucket for sparse thesis (dedup window)

### ✅ Ticket 3: Fast Decision Engine (`fast_decision_engine.py`)
**Commits:** `1e9f9bc`, `9fdee9c`, `72f9077`, `10d5751`
- `evaluate_signal_fast()` — runs all 15 policy gates in <3s
- Direct function call (no subprocess, no LLM in hot path)
- SQLite as truth (not JSON files)
- Policy packet with full evidence chain
- Router integration: replaces `subprocess sanad_pipeline.py`
- Gate 9 field + state_override support
- 30/30 policy engine unit tests passing

### ✅ Ticket 4: Cold Path Async Analysis Queue (`async_analysis_queue.py`)
**Commits:** `2c22445` → `b0684d6` (5 rejection cycles, approved at v5)
- Real LLM calls: Sanad/Bull/Bear (Claude Haiku) + Judge (GPT-5.2)
- `llm_client.py` — API calls with OpenRouter fallback, cost tracking
- Strict JSON contracts with `extract_json_object()` + validation
- Race-safe state machine: all transitions guarded by `AND status='RUNNING'` + rowcount checks
- `task_type='ANALYZE_EXECUTED'` filter in poll + claim
- Retry schedule: 300s / 900s / 3600s / FAILED (max_attempts: 4)
- Catastrophic flagging: Judge verdict=REJECT + confidence≥85 → `FLAG_JUDGE_HIGH_CONF_REJECT`
- 3 deterministic tests passing

### ✅ Ticket 5: Learning Loop (`learning_loop.py`)
**Commits:** `d3807d8` → `b301284` (4 rejection cycles, approved at v4)
- `process_closed_position()` — single-transaction exactly-once processing
- `BEGIN IMMEDIATE` + atomic claim (`WHERE status='CLOSED' AND learning_status='PENDING'`)
- Atomic SQL increments for Thompson (`alpha=alpha+?, beta=beta+?, n=n+1`)
- Atomic SQL increments for UCB1 (`n=n+1, reward_sum=reward_sum+?`)
- Canonical source keys via `signal_normalizer.canonical_source()`
- Enricher guard via `signal_normalizer.is_enricher()` (skips solscan/rugcheck/helius)
- Durable `learning_status` state machine: PENDING → RUNNING → DONE/FAILED
- Legacy NULL backfill in `init_db()`
- Canonical DB path: `SANAD_DB_PATH` env > `SANAD_HOME/state/` > `__file__`-relative
- 9 deterministic tests (isolated temp DB): WIN, LOSS, accumulation, exactly-once, guards, concurrency, DONE persistence, legacy backfill, DB path consistency

---

## REMAINING TICKETS (Not Yet Started)

### ⬜ Ticket 6: Wire Learning Loop to Production Lifecycle
**Priority:** HIGH — learning_loop.py exists but isn't triggered automatically
- **Option A (recommended):** Add cron: `*/5 * * * *` runs `python3 scripts/learning_loop.py`
- **Option B:** Trigger from `position_monitor.py` after closing a position
- Wire `update_position_close()` → `learning_status='PENDING'` (already done in state_store)
- Verify end-to-end: close event → PENDING → learning_loop picks up → DONE → stats updated

### ⬜ Ticket 7: Wire Async Analysis Queue to Production
**Priority:** HIGH — async_analysis_queue.py exists but needs cron
- Add cron for `python3 scripts/async_analysis_queue.py` (every 5 min or on-demand)
- Verify: position opens → ANALYZE_EXECUTED task created → queue picks up → LLM analysis → results written back

### ⬜ Ticket 8: Router Integration Complete
**Priority:** HIGH — router partially integrated but needs validation
- Verify `signal_router.py` calls `fast_decision_engine.evaluate_signal_fast()` (not subprocess)
- Verify all decisions (EXECUTE/SKIP/BLOCK) logged to SQLite
- Verify DBBusyError fallback to JSONL works
- End-to-end test: signal arrives → fast decision → position opened → async task enqueued

### ⬜ Ticket 9: Merge v3.1 Branch to Main
**Priority:** MEDIUM — after all tickets validated in production
- Merge `v3.1-ticket-4` → `main`
- Update MASTER_BUILD_PLAN.md with v3.1 completions
- Update IDENTITY.md version to v3.1

### ⬜ Ticket 10: Learning Loop → Strategy Selection Feedback
**Priority:** MEDIUM — Thompson/UCB1 stats written but not read by hot path
- `fast_decision_engine` should read `bandit_strategy_stats` for Thompson sampling
- `fast_decision_engine` should read `source_ucb_stats` for UCB1 source grading
- Replace file-based `state/thompson_state.json` and `state/ucb1_source_grades.json`
- Single source of truth: SQLite tables only

### ⬜ Ticket 11: Fractional Kelly Criterion (Dynamic Position Sizing)
**Priority:** LOW — currently cold-start 2% flat sizing
- Compute Kelly fraction from `bandit_strategy_stats` win rates
- Half-Kelly (0.50 fraction) as documented in risk-management.md
- 30-trade minimum before Kelly activates (enforced programmatically)
- Wire into `fast_decision_engine` position sizing

---

## ARCHITECTURE DIAGRAM (v3.1)

```
Signal Sources (CoinGecko, DexScreener, Birdeye, Meme Radar, etc.)
       ↓
  signal_router.py
       ↓
  fast_decision_engine.evaluate_signal_fast()  ← HOT PATH (<3s)
  ├── 15 policy gates (deterministic Python)
  ├── Thompson Sampling strategy selection (SQLite)
  ├── UCB1 source grading (SQLite)
  ├── Kelly position sizing
  └── EXECUTE / SKIP / BLOCK
       ↓
  state_store.try_open_position_atomic()
  ├── Decision → decisions table
  ├── Position → positions table (status=OPEN)
  └── Task → async_tasks table (ANALYZE_EXECUTED)
       ↓
  async_analysis_queue.py  ← COLD PATH (background)
  ├── Sanad Verifier (Claude Haiku)
  ├── Bull Al-Baqarah (Claude Haiku)
  ├── Bear Al-Dahhak (Claude Haiku)
  ├── Al-Muhasbi Judge (GPT-5.2)
  └── Catastrophic flag if Judge rejects with high confidence
       ↓
  position_monitor.py (every 60s)
  ├── Stop-loss / Take-profit / Trailing stop
  ├── Time exit / Volume death / Flash crash
  └── Close → update_position_close() → learning_status='PENDING'
       ↓
  learning_loop.py  ← LEARNING (exactly-once)
  ├── Claim: BEGIN IMMEDIATE + atomic WHERE PENDING
  ├── Update bandit_strategy_stats (Thompson α/β)
  ├── Update source_ucb_stats (UCB1 n/reward)
  └── Mark DONE → feeds back to hot path
```

---

## KEY FILES (v3.1)

| File | Ticket | Purpose |
|------|--------|---------|
| `scripts/state_store.py` | 1, 5 | SQLite state store + schema + migrations |
| `scripts/ids.py` | 2 | Canonical ID generation (signal, decision, position) |
| `scripts/fast_decision_engine.py` | 3 | Hot path: 15 gates in <3s |
| `scripts/async_analysis_queue.py` | 4 | Cold path: LLM analysis queue |
| `scripts/llm_client.py` | 4 | Real API calls (Claude + GPT + OpenRouter) |
| `scripts/learning_loop.py` | 5 | Exactly-once Thompson/UCB1 updates |
| `scripts/signal_router.py` | 3, 8 | Signal intake → fast decision engine |
| `scripts/position_monitor.py` | — | Position lifecycle (already v3.0) |
| `config/thresholds.yaml` | 4 | Single config source of truth |

---

*Last updated: 2026-02-22 06:50 MYT*
